## 3.2 Comments

`/* */` comments do not nest in Java.

## 3.3 Data Types

There are 8 primitive types in Java: four integer types(`byte`, `short`, `int`, `long`), two floating-point types(`float`, `double`), `char` and `boolean`.

### 3.3.1 Integer Types

| Type    | Storage requirement | Range                      |
| ------- | ------------------- | -------------------------- |
| `byte`  | 1 byte              | -128 to 127                |
| `short` | 2 bytes             | -32768 to -32767           |
| `int`   | 4 bytes             | -2147483648 to -2147483647 |
| `long`  | 8 bytes             | $-2^{63}$ to $2^{63}-1$    |

- `long` integer numbers have a suffix `L` or `l`.
- Hexadecimal numbers have a prefix `0x` or `0X`. Octal numbers have a prefix `0`. Binary numbers have a prefix `0b` or `0B`.
- You can add underscores to numbers.

### 3.3.2 Floating-Point types

| Type     | Storage Requirement |
| -------- | ------------------- |
| `float`  | 4 bytes             |
| `double` | 8 bytes             |

- `float` numbers have a suffix `F` or `f`. Floating-point numbers without an float suffix are always considered to be of type `double`, or you can optionally supply the `D` or `d` suffix.
- `0x1.0p-3` = $2^{-3}$. When the mantissa is written in hexadecimal, the base of the exponent is 2 rather then 10.
- `NaN` are considered distinct from any value, even with itself.

### 3.3.4 Unicode and the `char` Type

- Unicode escape sequences are processed before the code is parsed.
- `char` types stores a *code unit* in the UTF-16 encoding.

> A code point is a code value that is associated with a character in an encoding scheme. In the Unicode standard, code points are written in hexadecimal and prefixed with `U+`, such as `U+0041` for the code point of the Latin letter A. 
>
> Unicode has code points that are grouped into 17 code planes. The first code plane, called the basic multilingual plane, consists of the “classic” Unicode characters with code points `U+0000` to `U+FFFF`. Sixteen additional planes, with code points `U+10000` to `U+10FFFF`, hold the supplementary characters.
>
> The characters in the basic multilingual plane are represented as 16-bit values, called *code units*. The supplementary characters are encoded as consecutive pairs of code units. Each of the values in such an encoding pair falls into a range of 2048 unused values of the basic multilingual plane, called the surrogates area (`U+D800` to `U+DBFF` for the first code unit, `U+DC00` to `U+DFFF` for the second code unit). This is rather clever, because you can immediately tell whether a code unit encodes a single character or it is the first or second part of a supplementary character. For example, (the mathematical symbol for the set of octonions, http://math.ucr.edu/home/baez/octonions) has code point `U+1D546` and is encoded by the two code units `U+D835` and `U+DD46`. (See https://tools.ietf.org/html/rfc2781 for a description of the encoding algorithm.)

## 3.4 Variables and Constants

### 3.4.1 Declaring Variables

- In Java, identifiers are made up of letters, digits, currency symbol and "punctuation connectors". The first characters cannot be a digit.
- Note that letter here refers to any Unicode character that denotes a letter in a language. Similarly, digits are 0-9 and any Unicode characters that denote a digit. Currency symbols are $, €, ¥, and so on. Punctuation connects include the underscore character(_) and a few others.
- Identifiers are **case-sensitive**.
- `$` is a valid character in an identifier, but should not use it in your own code since it's intended for names that are generated by the Java complier and other tools. Most programmers stick to A-Z, a-z, 0-9 and the underscore(_).

### 3.4.2 Initializing Variables

- You can declare a variable and leave it uninitialized, but you can never use the value of it before it's initialized.

Starting with Java 10, you do not need to declare the types of local variables if they can be inferred from the initial value.

```java
var vacationDays = 12; // int
var greeting = "Hello"; // String
```

### 3.4.3 Constants

Use `final` to declare a constant:

```JAVA
final double CM_PER_INCH = 2.54;
```

### 3.4.4 Enumerated Types

```java
enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE };
Size s = size.MEDIUM;
```

## 3.5 Operators

### 3.5.3 Conversions between Numeric types

Legal conversions(*widening primitive conversion*, exactly) between numeric types:

![image-20220212223852248](/home/arv/.config/Typora/typora-user-images/image-20220212223852248.png)

When two values are combined with a binary operator, both operands are converted to a common type before the operation is carried out:

- If either of the operands is type `double`, the other one will be converted to a `double`.
- Otherwise, if either of the operands is of type `float`, the other one will be converted to a `float`
- Otherwise, if either of the operands is of type `long`, the other one will be converted to a `long`.
- Otherwise, **both operands will be converted to an `int`**.

Therefore, the following code will raise an error:

```
jshell> short x = 3;
jshell> short y = x * x;

|  Error:
|  incompatible types: possible lossy conversion from int to short
|  short y = x * x;
|            ^---^
```

### 3.5.4 Casts

Conversions in which loss of information, or the *narrow primitive conversion* is possible are done by means of *casts*.

```java
double x = 9.997;
int nx = (int) x; // nx=9
```

- You can **NOT** cast between `boolean` values and any numeric type.

### 3.5.5 Assignment

An assignment is an expression. That is, it has a value-- namely, the value that is being assigned.

```java
int x = 1;
int y = x += 4; // y=5
```

### 3.5.9 Switch Expressions

As of Java 14, there re four forms of `switch`. This section focuses on the most useful one.

```java
String seasonName = switch (seasonCode) {
        case 0 -> "Spring";
        case 1 -> "Summer";
        case 2 -> "Fall";
        case 3 -> "Winter";
        default -> "???";
};
```

Multiple labels are separated by commas:

```java
int numLetters = switch (seasonName) {
        case "Spring", "Summer", "Winter" -> 6;
        case "Fall" -> 4;
        default -> -1;
};
```

When you use the `switch` expression with enumerated constants, you need not supply the name of the enumeration in each label:

```java
enum Size {Small, MEDIUM, LARGE, EXTRA_LARGE};
Size itemSize = Size.MEDIUM;
String label = switch (itemSize) {
	case SMALL -> "S";
    case MEDIUM -> "M";
    case LARGE -> "L";
    case EXTRA_LARGE -> "XL";
};
```

### 3.5.10 Bitwise Operators

The `>>` operator extends the **sign bit** into the top bits, whereas the `>>>` operator fills the top bits with zero.

There's no `<<<` operator.

## 3.6 Strings

### 3.6.1 Substrings

The substring begins at the specified `beginIndex` and extends to the character at index `endIndex - 1`. 

```java
String greeting = "Hello";
String s = greeting.substring(0, 3); //Hel
```

### 3.6.2 Concatenation

You can use `+` operator to concatenate two strings.

To put multiple strings together, separated by a delimiter, use the `join` method:

```java
String message = String.join("-", "Java", "is", "cool");
// message returned is: "Java-is-cool"
```

As of Java 11, there's a `repeat` method:

```java
String repeated = "Java".repeat(3);
// JavaJavaJava
```

### 3.6.3 Strings Are Immutable

The objects of the `String` class are immutable. That is, you cannot change the individual characters in a Java String.

If you want to modify a string, then what you need to do is to concatenate the substring that you want to keep with the characters that you want to replace:

```java
String greeting = "Hello";
greeting = greeting.substring(0, 3) + "p!";
```

In fact, a Java string is roughly analogous to a `char *` pointer in C/C++.

### 3.6.4 Testing Strings for Equality

Do **NOT** use the `==` operator to test whether two strings are equal. It only determines whether or not the strings are stored in the same location.

You should use the `equals` method instead.

```java
s.equals(t);
"Hello".equals(greeting);
"Hello".equalsIgnoreCase("hello");
```

### 3.6.5 Empty and Null Strings

The empty string `""` is a string of length 0.

Sometimes, you need to test that a string is neither `null` nor empty. Then use:

```java
if (str != null && str.length() != 0)
```

### 3.6.6 Code Points and Code Units

The `length` method yields the number of **code units** required for a given string in the UTF-16 encoding.

To get the true length, that is, the number of code points, call `codePointCount`, which returns the number of Unicode **code points** in the text range of the string.

`s.char(n)` returns the **code unit** at position n.

To get at the ith **code point**, use the statements:

```java
int index = greeting.offsetByCodePoints(0, i);
int cp = greeting.codePointAt(index);
```

### 3.6.9 Building Strings

Occasionally, you need to build up strings from shorter strings. It would be inefficient to use string concatenation for this purpose, since every time you concatenate strings, a new `String` object is constructed which is time-consuming and wastes memory.

Use `StringBuilder` class to avoid this problem.

```java
StringBuilder builder = new StringBuilder();
builder.append(ch); // appends a single character
builder.append(str); // appends a string
String completedString = builder.toString();
```

### 3.6.10 Text Blocks

This feature is added in Java 15.

A text block starts with `"""`, followed by a line feed and ends with another `"""`.

```java
String greeting = """
Hello
World
""";
```

The equivalent string is:

```
"Hello\nWorld\n"
```

Note that the newline after the opening `"""` is not included in the string literal.

- All backslashes still need to be escaped.
- Line endings are normalized by removing trailing whitespace and changing any Windows line endings (`\r\n`) to simple newlines (`\n`).
- If you need to preserve trailing spaces, turn the last one into a `\s` escape.
- For leading white space, indentation that is common to all lines in the text block is subtracted.

## 3.7 Input and Output

### 3.7.1 Reading Input

```java
Scanner in = new Scanner(System.in);

System.out.print("What is your name? ");
String name = in.nextLine();

System.out.print("How old are you? ");
int age = in.nextInt();
```

```java
String firstName = in.next();
```

To read a password, use:

```java
Console cons = System.console();
String username = cons.readLine("User name: ");
char[] passwd = cons.readPassword("Password: ");
```

### 3.7.2 Formatting Output

- `System.out.printf`
- `String.format`
- `String.formatted` (since Java 15)

```java
String message = String.format("Hello, %s. Next year, you'll be %d", name, age + 1);
String message = "Hello, %s. Next year, you'll be %d".formatted(name, age + 1);
```

### 3.7.3 File Input and Output

To read an file, use:

```java
Scanner in = new Scanner(Path.of("myfile.txt"), StandardCharsets.UTF_8);
```

Remember that if the file name contains backslashes, then you need to escape each of them with an additional backslash. For example:

```
"c:\\mydirectory\\myfile.txt"
```

To write to a file, construct a `PrintWriter` object and do as printing to `System.out`.

```java
PrintWriter out = new PrintWriter("myfile", StandardCharsets.UTF_8);
```

The file is created if it does not exist.

----

When you specify a relative file name, the file is located relative to the directory in which the **Java virtual machine was started**.

## 3.8 Control Flow

### 3.8.1 Block Scope

A block, or compound statement, consists of a number of Java statements, surrounded by a pair of braces. 

In C++, it's possible to redefine a variable inside a nested block and then the inner definition shadows the outer one. However, Java does **NOT** allow it since it can be a source of programming errors.

### 3.8.5 Multiple Selections with `switch`

A case label can be

- A constant expression of type char, byte, short, or int
- An enumerated constant
- A string literal
- More than one of these, separated by commas

The four forms of `switch`

![](/home/arv/.config/Typora/typora-user-images/image-20220213204145407.png)

Note the `yield` keyword with switch expressions. Like `break`, it terminates execution. Unlike `break`, it also yields a value—the value of the expression.

### 3.8.6 Statements That Break Control Flow

Java offers a labeled break statement that lets you break out of multiple nested loops.

For example,

```java
read_data:
while (. . .) // this loop statement is tagged with the label
{
   . . .
   for (. . .) // this inner loop is not labeled
   {
      System.out.print("Enter a number >= 0: ");
      n = in.nextInt();
      if (n < 0) // should never happen—can't go on
         break read_data;
         // break out of read_data loop
      . . .
   }
}
// this statement is executed immediately after the labeled break
if (n < 0) // check for bad situation
{
   // deal with bad situation
}
else
{
   // carry out normal processing
}
```

## 3.9 Big Number

The content is left out.

## 3.10 Arrays

### 3.10.1 Declaring Arrays

Declare an array `a` of integers:

```java
int[] a;
```

This statement does not initialize `a` with an actual array. Use the `new` operator to create the array:

```java
int[] a = new int[100];
```

Java has a shortcut for creating an array object and supplying initial values:

```java
int[] smallPrimes = { 2, 3, 5, 7, 11, 13 };
```

You can declare an anonymous array:

```java
new int[] { 17, 19, 23, 29, 31, 37 }
```

You can use this syntax to reinitialize an array without creating a new variable. For example,

```java
smallPrimes = new int[] { 17, 19, 23, 29, 31, 37 };
```

is shorthand for

```java
int[] anonymous = { 17, 19, 23, 29, 31, 37 };
smallPrimes = anonymous;
```

By the way, an array of length 0 is legal.

### 3.10.2 Accessing Array Elements

When you create an array of 

- numbers, all elements are initialized with zero.
- boolean, all elements are initialized with `false`.
- objects, all elements are initialized with `null`

An easy way to print all values of an array `a`:

```java
System.out.println(Arrays.toString(a));
```



### 3.10.3 The "for each" Loop

<pre>
    for (<em>variable</em> : <em>collection</em>) <em>statement</em>
</pre>

The "for each" loop allows you to loop through each element in an array or an object of a class that implements the `Iterable` interface, such as `ArrayList`.

### 3.10.4 Array Copying

A Java array acts like a pointer in C/C++.

You can copy one array variable variable into another, but then both variables refer to the same array.

```java
int[] luckyNumbers = smallPrimes;
luckyNumbers[5] = 12; // now smallPrimes[5] is also 12
```

If you actually want to copy all the values of one array into a new array, use the `copyOf` method:

```java
int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length);
```

### 3.10.5 Command-Line Parameters

If the program is called as

```
java Message -g cruel world
```

then the args array has the following contents:

```
args[0]: "-g"
args[1]: "cruel"
args[2]: "world"
```

Note that different from C++, the name of the program is not included in the `args` array.

### 3.10.7 Multi-dimensional Arrays

In fact, Java has no multidimensional arrays at all, only one-dimensional arrays. Multi-dimensional arrays are faked as “**arrays of arrays**”.

Therefore, It is possible to make “ragged” arrays—that is, arrays in which different rows have different lengths.

Example of 2d array:

```java
int [][] magicSquare = {
    {16, 3, 2, 13},
    {5, 10, 11, 8},
    {9, 6, 7, 12},
    {4, 15, 14, 1}
};
```

Consider the following code:

```cpp
int[][] multi = new int[5][10];
```

which is actually a shorthand for

```java
int[][] multi = new int[5][]; // allocate the array holding the rows
multi[0] = new int[10];
multi[1] = new int[10];
multi[2] = new int[10];
multi[3] = new int[10];
multi[4] = new int[10];
```

where all elements are initialized to zero.

https://stackoverflow.com/questions/12231453/syntax-for-creating-a-two-dimensional-array-in-java

----

To print out a quick-and-dirty list of the elements of a two-dimensional array, call

```java
System.out.println(Arrays.deepToString(a));
```

The output is formatted like this:

```
[[16, 3, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]]
```

# Chapter 4. Objects and Classes

## 4.2 Using Predefined Classes

### 4.2.1 Objects and Object Variables

It's important to realize that an object variable doesn't actually contain an object. It only **refers** to an object.

You can think of Java object variables as analogous to object pointers in C++.

### 4.2.3 Mutator and Accessor Methods

booMethods that only access objects without modifying them are called *accessor methods*. In contrast, methods thats modify objects are called *mutator methods*.



## 4.3 Defining Your Own Classes

In Java,

- A construct is **ALWAYS** called with the `new` operator.
- All methods all methods are defined inside the class itself. You cannot define a method outside the class.

----

- If you need to return a reference to a mutable object in an accessor method, you should clone it first.

### 4.3.5 Declaring Local Variables with `var`

As of Java 10, you can declare local variables with the `var` keyword instead of specifying their type, provided their type can be inferred from the initial value.

For example, instead of declaring

```java
Employee harry = new Employee("Harry Hacker", 50000, 1989, 10, 1);
```

you simply write

```java
var harry = new Employee("Harry Hacker", 50000, 1989, 10, 1);
```

### 4.3.6 Working with `null` references

**java.util.Objects** 7

- <pre>static &lt;T&gt; void requireNonNull(T obj)</pre>

- <pre>static &lt;T&gt; void requireNonNull(T obj, String message)</pre>

- <pre>static &lt;T&gt; void requireNonNull(T obj, Supplier&lt;String&gt; messageSupplier) 8</pre>

If obj is null, these methods throw a `NullPointerException` with no message or the given message.

- <pre>static &lt;T&gt; T requireNonNullElse(T obj, T defaultObj) 9</pre>

- <pre>static &lt;T&gt; T requireNonNullElseGet(T obj, Supplier&lt;T&gt; defaultSupplier) 9</pre>

returns `obj` if it is not `null`, or the default object if `obj` is `null`.

### 4.3.11 Final Instance Fields

You can define a field as `final`. Such a field must be initialized before the end of every constructor.

```java
class Employee {
    private final String name;
}
```

For objects, the `final` keyword merely means that the object reference stored in the variable will never again refer to a different object but can be mutated.

## 4.4 Static Fields and Methods

```java
class Employee {
    private static int nextId = 1;
    ...
    public static int advanceId() {
        int r = nextId;
        nextId++;
        return r;
    }
}
```



 ```JAVA
 public class Math {
     ...
 	public static final double PI = 3.14159265358979323846;
     ...
 }
 ```

**Factory method**: refers to a static method of a class that returns an object of that class' type.

## 4.5 Method Parameters

The Java programming language always uses ***call by value***, rather than *call by reference*.

For an object parameter, the method gets a copy of the object reference, and both the original and the copy refer to the same object.

## 4.6 Object Construction

### 4.6.1 Overloading

**Overloading**(**NOT overriding**) refers to that several methods have the same name but different parameters.

You are allowed to overload any methods, including constructor methods.

Unlike C++, overloading works regardless of **whether the method was defined at this level or in a base class.** For example,

```java
//: reusing/Hide.java
// Overloading a base-class method name in a derived
// class does not hide the base-class versions.
import static net.mindview.util.Print.*;
class Homer {
	char doh(char c) {
		print("doh(char)");
		return ‘d’;
	}
	float doh(float f) {
 		print("doh(float)");
 		return 1.0f;
 	}
}
class Milhouse {}
class Bart extends Homer {
	void doh(Milhouse m) {
	print("doh(Milhouse)");
	}
}
public class Hide {
	public static void main(String[] args) {
		Bart b = new Bart()；
		b.doh(1);
		b.doh(‘x’);
		b.doh(1.0f);
 		b.doh(new Milhouse());
	}
} 

/* Output:
doh(float)
doh(char)
doh(float)
doh(Milhouse)
*///:~ 
```



### 4.6.2 Default Field Initialization

As mentioned in the previous section, if you don't set a field explicitly, then it's automatically set to a default value: numbers to 0, `boolean` values to `false` and object references to `null`.

Moreover, there's an important differences between fields and local variables. You must always explicitly initialize local variables in a method. But in a class, if you don’t initialize a field, it is automatically initialized to a default.

### 4.6.3 The Constructor with No Arguments

Similar to C++, you get a free no-argument constructor only when your class has no other constructors.

### 4.6.6 Calling Another Constructor

For example,

```java
public Employee(double s) {
    // calls the constructor method Employee(String, double)
    this("Employee #" + nextId, s);
}
```

### 4.6.7 Initialization Blocks

Class declarations can contain arbitrary blocks of code. These blocks are executed whenever an object of that class is constructed. For example:

```java
class Employee
{
   private static int nextId;
   private int id;
   private String name;
   private double salary;

   // object initialization block   
   {
      id = nextId;
      nextId++;
   }

   public Employee(String n, double s)
   {
      name = n;
      salary = s;
   }

   public Employee()
   {
      name = "";
      salary = 0;
   }
   . . .
}
```

----

Here is what happens in detail when a constructor is called:

1. If the first line of the constructor calls a second constructor, then the second constructor executes with the provided arguments. 
2. Otherwise,
   - All instance fields are initialized to their default values (0, false, or null).
   - All field initializers and initialization blocks are executed, in the order in which they occur in the class declaration.

3. The body of the constructor is executed.

----

To initialize a static field, either supply an initial value or use a static initialization block. Static initialization occurs when the class is first loaded.

```java
private static Random generator = new Random();
// static initialization block
static {
    nextId = generator.nextInt(10000);
}
```

### 4.6.8 Object Destruction and the `finalize` Method

Java does not support destructors.

## 4.7 Records

### 4.7.1 The Record Concept

A record is a special form of a class whose state is immutable and readable by the public.

Here is how you define Point as a record:

```java
record Point(double x, double y) {}
```

The result is a class with instance fields:

```java
private final double x;
private final double y;
```

In the Java language specification, the instance fields of a record are called its **components**.

The class has a constructor

```java
Point(double x, double y)
```

and accessor methods

```java
public double x()
public double y()
```

In addition to the field accessor methods, every record has three methods defined automatically: `toString`, `equals`, and `hashCode`.

Moreover, you can define your own versions of the automatically provided methods, and add your own methods to a record. A record, like any class, can have static fields and methods. However, you cannot add instance fields to a record.

### 4.7.2 Constructors: Canonical, Custom, and Compact

The automatically defined constructor that sets all instance fields is called the ***canonical constructor***.

You can define additional custom constructors. The first statement of such a constructor must call another constructor. For example,

```java
record Point(double x, double y) {
    public Point() { this(0, 0); }
}
```

If the canonical constructor needs to do additional work, you can provide your own implementation:

```java
record Range(int from, int to) {
    public Range(int from, int to) {
        if (from <= to) {
            this.from = from;
            this.to = to;
        } else {
            this.from = to;
            this.to = from;
        }
	}
}
```

However, you are encouraged to use a ***compact*** form when implementing the canonical constructor. You don’t specify the parameter list:

```java
record Range(int from, int to) {
    public Range {
        if(from > to) {
            int temp = from;
            from = to;
            to = temp;
        }
    }
}
```

The body of the compact form is the “prelude” to the canonical constructor. It merely modifies the parameter variables `from` and `to` before they are assigned to the instance fields `this.from ` and `this.to`.

## 4.8 Packages

### 4.8.1 Package Names

In order to absolutely guarantee a unique package name, it's common to use an Internet domain name written in reverse and then append a project name, such as `com.horstmann.corejava`.

The convention for Java package names is to use all lowercase letters, even for intermediate words.

From the point of view of the compiler, there is absolutely no relationship between nested packages. For example, the packages `java.util` and `java.util.jar` have nothing to do with each other. Each is its own independent collection of classes.

### 4.8.2 Class Importation

You can access the public classes in another package in two ways.

The first is simply to use the *fully qualified name*. For example,

```java
java.time.LocalDate today = java.time.LocalDate.now();
```

A simpler, and more common approach is to use the `import` statement. For example,

```java
import java.time.LocalDate;
LocalDate today = LocalDate.now();
```

You can also import the whole package.

```java
import java.time.*;
```

If you run into a name conflict, for example, both the `java.util` and `java.sql` packages have a `Date` class,

```java
import java.util.*;
import java.sql.*;
```

then you need to add a specific `import` statement:

```java
import java.util.*;
import java.sql.*;
import java.util.Date;
```

### 4.8.3 Static Imports

Static imports permit the importing of static methods and fields, not just classes.

For example, if you add the directive

```java
import static java.lang.System.*;
```

to the top of your source file, then you can use the static methods and fields of the System class without the class name prefix:

```java
out.println("Goodbye, World!"); // i.e., System.out
exit(0); // i.e., System.exit
```

You can also import a specific method or field:

```java
import static java.lang.System.out;
```

### 4.8.4 Addition of a Class into a Package

To place classes inside a package, put the name of the package **at the top** of your source file, **before** any non-comment code.

For example,

```java
package com.horstmann.corejava;
public class Employee {
    ...
}
```

Also, place source files into a subdirectory that matches the full package name. For example, all source files in the `com.horstmann.corejava` package should be in a subdirectory `com/horstmann/corejava`.

If you don't put a `package` statement in the source file, then the classes in that source file belong to the *unnamed package*.

### 4.8.5 Package Access

### 4.8.6 The Class Path

The process of locating `.class` files is as follows. 

- First, it finds the environment variable `CLASSPATH`, which contains one or more directories that are used as roots in a search for `.class` files. 
- Starting at that root, the interpreter will take the package name and replace each dot with a slash to generate a path name off of the `CLASSPATH` root (so package `foo.bar.baz` becomes `foo/bar/baz` ). This is then concatenated to the various entries in the `CLASSPATH`. That’s where it looks for the `.class` file with the name corresponding to the class you’re trying to create. 

There’s a variation when using JAR files, however. You must put the actual name of the JAR file in the `CLASSPATH`, not just the path where it’s located.

----

It is best to specify the class path with the option -classpath (or -cp or, as of Java 9, --class-path):

```cpp
java -classpath /home/user/classdir:.:/home/user/archives/archive.jar MyProg
```

This class path overrides the user class path in the `CLASSPATH` environment variable.

If `--class-path`, `-classpath`, or `-cp` are not specified, then the user class path is the value of the `CLASSPATH` environment variable, if that is set, or else the current directory.

Therefore, don't forget to include the current directory `.` in your manually set class path.

## 4.9 JAR Files

When you package your application, you want to give your users a single file, not a directory structure filled with class files. Java Archive (JAR) files were designed for this purpose. 

A JAR file can contain both class files and other file types such as image and sound files. Moreover, JAR files are compressed, using the familiar ZIP compression format.

`jar` program options:

![image-20220216151306660](/home/arv/.config/Typora/typora-user-images/image-20220216151306660.png)

### 4.9.1 Creating JAR Files

```
jar cvf jarFileName file1 file2 . . .
```

### 4.9.2 The Manifest

In addition to class files, images, and other resources, each JAR file contains a manifest file that describes special features of the archive.

The manifest file is called `MANIFEST.MF` and is located in a special `META-INF`subdirectory of the JAR file. The minimum legal manifest is quite boring—just

```
Manifest-Version: 1.0
```

# Chapter 5. Inheritance

## 5.1 Classes, Superclasses and Subclasses

### 5.1.1 Defining Subclasses

```java
public class Manager extends Employee {}
```

Note that all inheritance in Java is the concept of **public inheritance** in C++.

### 5.1.2 Overriding Methods

Use the keyword `super` as prefix to refer to methods of parent class.

```java
class Employee {
    public double getSalary() {
        ...
    }
}

class Manager extends Employee {
    private double bonus;
    public double getSalary() {
        return super.getSalary() + bonus;
    }
}
```

When you override a method, the subclass method must have the same signature and return type as in the base class.

Furthermore, the subclass method must be at least as visible as the superclass method. For example, if the superclass method is `public`, then the subclass method must also be declared `public`.

When you mean to override a method, you can choose to add the `@Override` annotation and the complier will produce an error message if you accidentally overload instead of overriding.

### 5.1.3 Subclass Constructors

The call using `super` must be the first statement in the constructor for the subclass.

When a subclass object is constructed without explicit invocation of a super-class constructor, the superclass must have a no-argument constructor that will be implicitly called.

```java
public Manager(String name, double salary, int year, int month, int day) {
    super(name, salary, year, month, day);
    bonus = 0;
}
```

### 5.1.4 Inheritance Hierarchies

Java does not support multiple inheritance.

### 5.1.7 Preventing Inheritance: Final Classes and Methods

Classes that cannot be extended are called *final* classes, and you use the `final` modifier in the definition of the class to indicate this. For example,

```java
public final class Executive extends Manager {
    ...
}
```

You can also make a specific method in a class `final` and then no subclass can override that method. For example:

```java
public class Employee {
    public final String getName {...}
}
```

### 5.1.8 Casting

Usually, when you want to use an object in its full capacity after its actual type has been temporarily forgotten, you need to make a cast.

Consider the superclass `Employee` and the subclass `Manager`:

```java
class Employee {
    public void setSalary() {...}
}

class Manager {
    public void setSalary() {...}
    public void setBonus() {...}
}

Employee[] staff = new Employee[2];
staff[0] = new Employee();
staff[1] = new Manager();

staff[1].setSalary(); // invoke Manager.setSalary()
staff[1].setBonus(); // failed
(Manager) staff[1] // ok
```

You can cast only within an inheritance hierarchy. Otherwise, an exception is thrown.

### 5.1.9 Pattern Matching for `instanceof`

This feature is added in Java 16.

The code

```java
if(staff[i] instanceof Manager) {
    Manager boss = (Manager) staff[i];
    boss.setBonus(5000);
}
```

is rather verbose.

As of Java 16, you can declare the subclass variable right in the `instanceof` test:

```java
if(staff[i] instanceof Manager boss) {
    boss.setBonus(5000);
}
```

### 5.1.10 Access Modifiers

Here's a summary of the four access control modifiers in Java:

- `private`: accessible in the class only
- `public`: accessible by the world
- `protected`: accessible in the **package** and all subclasses
- `package`: accessible in the package, the **default** modifier

## 5.2 `Object`: The Cosmic Superclass

In Java, only the values of primitive types(numbers, characters, and boolean values) are not objects and every class extends `Object`.

Note that all array types, no matter whether they are arrays of objects or arrays of primitive types, are class types that extend the `Object` class.

### 5.2.2 The `equals` Method

The `equals` methods determines whether two object references are identical.

Here's a common mistake when implementing the `equals` method:

```java
public class Employee {
    public boolean equals(Employee other) {
        ...
    }
}
```

This method declares the explicit parameter type as `Employee`. As a result, it does not override the `equals` method of the `Object` class but defines a completely unrelated method.

You can protect yourself against this kind of error by tagging methods that are intended to override superclass methods with `@Override`:

```java
@Override
public boolean equals(Object other)
```

If you made a mistake and are defining a new method, then the compliers reports an error.

### 5.2.3 Equality Testing and Inheritance

The Java Language Specification requires that the `equals` method has the following properties:

- reflexive
- symmetric
- transitive
- consistent
- `x.equals(null)` should return false

----

Use `instanceof` or `getClass()`:

- If subclasses can have their own notion of equality, then the symmetry requirement forces you to use the `getClass` test.
- If the notion of equality is fixed in the superclass, then you can use the `instanceof` test and allow objects of different subclasses to be equal to one another. (Often you need to make the `equals` method `final`)

----

A recipe for writing `equals` methods:

`otherObject` is the parameter

1. Test whether `this` happens to be identical to `otherObject`

   ```java
   if (this == otherObject) return true;
   ```

2. Test whether `otherObject` is null

   ```java
   if(otherObject == null) return false;
   ```

3. Compare the classes of `this` and `otherObject`. Choose `getClass` or `instanceof` accordingly.

4. Compare the fields. Use `==` for primitive type fields and `Object.equals` for object fields.

By the way, sometimes it's useful include a call to `super.equals` because it may have covered the check of some fields.

### 5.2.4 The `hashCode` Method

```java
public int hashCode()
```

The `hashCode` method defined in the `Object` class returns an integer derived from the object's memory address.

Your definitions of `equals` and `hashCode` must be compatible, i.e., if `x.equals(y)` is true, then `x.hashCode()` must return the same value as `y.hashCode()`.

---

Combine multiple hash values:

```java
public int hashCode() {
    return Objects.hash(name, salary, hireDay);
}
```

### 5.2.5 The `toString` Method

Most `toString` methods follow this output format: the name of the class, then the field values enclosed in square brackets. For example, the `toString` method of the `Point` class returns a string like this:

```
java.awt.Point[x=2,y=3]
```

The `Object` class defines the `toString` method to print the class name and the hash code of the object. For example:

```
java.io.PrintStream@4617c264
```

## 5.3 Generic Array Lists

### 5.3.1 Declaring Array Lists

```java
ArrayList<Employee> staff = new ArrayList<Employee>();
```

You can take advantage of the so-called "diamond" syntax to omit the type parameter on the right-hand side.

```java
ArrayList<Employee> staff = new ArrayList<>();
```

The size of array `ArrayList` is dynamic. If you know or have a good guess about how many elements you want to store, you can pass the capacity to the constructor. And the array list is also automatically enlarged when it's full.

```java
ArrayList<Employee> staff = new ArrayList<>(100);
```

Use the `add` method to add new elements to an array list:

```java
staff.add(new Employee("Harry Hacker", ...));
```

### 5.3.2 Accessing Array List Elements

To set the ith element, use

```java
staff.set(i, harry);
```

Do **NOT** call `list.set(i, x)` until the size of the array list is large than `i`.

**Use the `add` method instead of `set` to fill up an array, and use `set` only to replace a previously added element.**

----

To get an array list element, use

```java
Employee e = staff.get(i);
```

## 5.4 Object Wrappers and Autoboxing

Occasionally, you need to convert a primitive type like `int` to an object. All primitive types have class counterparts. For example, a class `Integer` corresponds to the primitive type `int`. These kinds of classes are usually called wrappers.

The wrapper classes are immutable. They are also `final`, so you cannot subclass them.

Do not use wrapper class constructors. They are deprecated and scheduled for removal. For example, use `Integer.valueOf(1000)`, never `new Integer(1000)`, or simply rely on auto-boxing: `Integer a = 1000`

## 5.5 Methods with a Variable Number of Parameters

The ellipsis `...` denotes that the method can receive an arbitrary number of objects.

Consider the method `System.out.printf`

```java
public PrintStream printf(String format, Object ... args) {
    return format(format, args);
}
```

The `printf` method actually receives two parameters: the format string and an `Object[]` array that holds all other parameters.

## 5.6 Abstract Classes

If you use the `abstract` keyword for a method, then you do not need to implement the method at all.

```java
public abstract String getDescription();
```

A class with one or more abstract methods must be declared `abstract`. **Abstract classes cannot be instantiated**.

```java
public abstract class Person {
    public abstract String getDescription();
    ...
}
```

But conversely, abstract classes may not necessarily contain abstract methods.

In addition to abstract methods, abstract classes can have fields and concrete methods.

```java
public abstract class Person {
    private String nam;
    public Person(String name) {
        this.name = name;
    }
    public abstract String getDescription();
    public String getName() {
        return name;
    }
}
```

When you extend an abstract class, you have two choices: you can leave some or all of the abstract methods undefined and then you must tag the subclass as `abstract`. Or, you can define **all** methods and the subclass is not longer abstract.

## 5.7 Enumeration Classes

```java
public enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE }
```

The type defined by this declaration is actually a class and the class has exactly four instances.

You can add constructors, methods and fields to an enumerated type. The constructor of an enumeration is always and automatically private.

```java
public enum Size {
    SMALL("S"), MEDIUM("M"), LARGE("L"), EXTRA_LARGE("XL");
    private String abbreviation;
    Size(String abbreviation) {
        this.abbreviation = abbreviation;
    }
    public String getAbbreviation() {
        return abbreviation;
    }
}
```

## 5.9 Reflection

The *reflection library* allows Java programs to dynamically inquire about the capabilities of classes.

### 5.9.1 The `Class` Class

The virtual machine manages a unique `Class` object for each type. 

The `getCLass()` method in the `Object` class returns an instance of `Class` type:

```java
Employee e = new Employee();
Class cl = e.getClass();
```

You can obtain a `Class` object corresponding to a class name through the static `forName` method:

```java
String className = "java.util.Random";
Class cl = Class.forName(className);
```

Alternatively, use the shorthand `T.class` where `T` is any Java type.

```java
Class cl1 = Random.class;
Class cl2 = int.class;
Class cl3 = Double[].class;
Class cl4 = void.class;
```

----

If you have an object of type `Class`, you can use it to construct instance of the class.

```java
var className = "java.util.Random";
Class cl = Class.forName(className);
Object obj = cl.getConstructor().newInstance();
```

### 5.9.3 Resources

The `Class` class provides a useful service for locating resource files relative to the place where class files are located in.

```java
public class ResourceTest {
    public static void main(String[] args) throws IOException {
        Class cl = ResourceTest.class;
        URL aboutURL = cl.getResource("about.gif");
        var icon = new ImageIcon(aboutURL);
        
        InputStream stream = cl.getResourceAsStream("data/about.txt");
        var about = new String(stream.readAllBytes(), "UTF-8");
        
        ...
    }
}
```

### 5.9.4 Using Reflection to Analyze the Capabilities of Classes

The three classes `Field`, `Method`, and `Constructor` in the `java.lang.reflect` package describe the fields, methods, and constructors of a class, respectively.

The `getFields`, `getMethods` and `getConstructor` methods of the `Class` class return arrays of the public fields, methods and constructors, including those inherited from superclasses and superinterfaces.

The `getDeclaredFields`, `getDeclaredMethods` and `getDeclaredConstructors` methods of the `Class` class return arrays consisting of all fields, methods and constructors that are declared in the class. This includes public, protected, default (package) access, and private members, but excludes inherited members.

### 5.9.5 Using Reflection to Analyze Objects at Runtime

If `f` is an object of type `Field` and `obj` is an object of the class of which `f` is a field, then `f.get(obj)` returns an object whose value is the current value of the field.

The call `f.set(obj, value)` sets the field represented by `f` of the object `obj` to the new value.

You can only use `get` and `set` with accessible fields since the default behavior of the reflection mechanism is to respect Java access control. However, you can override access control by invoking the `setAccessible` method.

### 5.9.6 Using Reflection to Write Generic Array Code

The method `Arrays.copyOf(arr, len)` can be used to grow an array that has become full to the length of `len`.

Now you are to implement such a method. Here's a first attempt:

```java
public static Object[] badCopyOf(Object[] a, int newLength) {
    var newArray = new Object[newLength];
    System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength));
    return newArray;
}
```

The problem is that this code returns an array of objects(`Object[]`) can an array of objects cannot be cast to an array of other types(e.g. `Employee[]`).

The point is that a Java remembers the type of its entries——that is, the element type used in the **`new` expression that created it**.

For example, it's legal to cast an `Employee[]` temporarily to an `Object[]` array and then cast it back, but an array that started its life as an `Object[]` array can never be cast into an `Employee[]` array.

Therefore, to write this kind of generic array code, we need to be able to make a new array of the same type as the original array. For this, you can use the static `newInstance` method of the `Array` class that constructs a new array.

```java
Object newArray = Array.newInstance(componentType, newLength);
```

```java
public static Object goodCopyOf(Object a, int newLength) {
    Class cl = a.getClass();
    if(!cl.isArray()) return null;
    Class componentType = cl.getComponentType();
    int length = Array.getLength(a);
    Object newArray = Array.newInstance(componentType, newLength);
    System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength));
    return newArray;
}
```

Note that the parameter of `goodCopyOf` is declared to be of type `Object` rather than `Object[]` since arrays of primitive types, such as `int[]` can be converted to an `Object`, but not to an array of objects.

### 5.9.7 Invoking Arbitrary Methods and Constructors

The `Method` class has an `invoke` method that lets you call the method that is wrapped in the current `Method` object.

```
Object invoke(Object obj, Object ... args)
```

The first parameter is the implicit parameter. For a static method, it can be ignored or set to `null`.

If the return type is a primitive type, the `invoke` method will return the wrapper type instead. Hence, you should cast it accordingly in this case:

```java
double s = (Double) m2.invoke(harry);
```

----

Invoke arbitrary constructors:

```java
Class cl = Random.class;
Constructor cons = cl.getConstructor(long.class);
Object obj = cons.newInstance(42L);
```

# Chapter 6. Interfaces, Lambda Expressions, and Inner Classes

## 6.1 Interfaces

### 6.1.1 The Interface Concept

- You can never use the `new` operator to instantiate an interface.
- Different from abstract classes, A class can implement one or multiple interfaces.
- All methods of an interface are automatically `public`.
- As of Java 8, you are allowed to add static methods to interfaces so that you don't need to provide a separate companion class for utility methods. Static methods in interfaces must have definitions.
- Interfaces never have instance fields but can have static fields(`public static final`). 
- To make a class implement an interface, you should supply definitions for all (abstract) methods in the interface.

```java
class Employee implements Comparable<Employee> {
    public int compareTo(Employee other) {
        return Double.compare(salary, other.salary);
    }
}
```

---

By the way, the `compareTo` method faces the same problem as the `equals` method when inheritance comes into play.

Since `Manager` extends `Employee`, it implements `Comparable<Employee>` and not `Comparable<Manager>`. If `Manager` chooses to override `compareTo`, it must be prepared to compare managers to employees. It can't simply cast an employee to a manager.

```java
class Manager extends Employee {
    public int compareTo(Employee other) {
        Manager otherManager = (Manager) other; // NO
    }
}
```

The remedy is the same as with the `equals` method:

- If subclasses have different notions of comparison, then you should start with a test outlawing comparison of objects are not accepted.

  ```java
  if (getClass() != other.getClass()) throw new ClassCastException();
  ```

- If there's a common algorithm for comparing subclass objects, simply provide a single `compareTo` method in the superclass and declare it as `final`.

### 6.1.5 Default Methods

You can supply a default implementation for any (non-static) interface method. You must tag such a method with the `default` modifier.

```java
public interface Iterator<E> {
    boolean hasNext();
    E next();
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
}
```

### 6.1.6 Resolving Default Method Conflicts

What happens if the exact same method is defined as a default method in one interface and then again as a method of a superclass or another interface?

The rules for resolving such conflicts are as follows:

- **Superclasses win**. If a superclass provides a concrete method, default methods with the same name and parameter types are simply ignored.
- **Interfaces clash**. If an interface provides a default method, and another interface contains a method with the same name and parameter types (default or not), then you must resolve the conflict by overriding that method.

You can never make a default method that redefines one of the methods in `Object` class. For example, you cannot define a default method for `toString` or `equals` because of the *superclasses win* rule.

### 6.1.8 The `Comparator` Interface

There's a second version of the `Arrays.sort` method whose parameter are an array, and a *comparator*, which is an instance of a class that implements the `Comparator` interface.

```java
public interface Comparator<T> {
	int compare(T first, T second);
}
```

For example, you want to compare strings by length, then define a class that implements `Comparator<String>`.

```java
class LengthComparator implements Comparator<String> {
    public int compare(String first, String second) {
        return first.length() - second.length();
    }
}
```



